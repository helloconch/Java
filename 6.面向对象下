1.equals和==
int a=10; 
int b=10; 
则a==b将是true。 
但不好理解的地方是： 
String a=new String( "foo "); 
String b=new String( "foo "); 
则a==b将返回false。 

对象变量其实是一个引用，它们的值是指向对象所在的内存地址，而不是对象本身。a和b都使用了new操作符，意味着将在内存中产生两个内容为 "foo "的字符串，既然是“两个”，它们自然位于不同的内存地址。a和b的值其实是两个不同的内存地址的值，所以使用 "== "操作符，结果会是false。诚然，a和b所指的对象，它们的内容都是 "foo "，应该是“相等”，但是==操作符并不涉及到对象内容的比较。 
对象内容的比较，正是equals方法做的事。 


2.接口
Java8允许在接口中定义默认方法，默认方法必须使用default修饰，该方法不能用static修饰，因此不能用接口直接调用默认方法，
需要使用接口的实现类的实例来调用这些默认方法。
Java8允许在接口中定义类方法，类方法必须使用static修饰，因此类方法可以直接使用接口来调用。
public interface Output {

	void out();

	public default void print() {

	}

	static String staticTest() {
		return "接口里的类方法";
	}

}

3.使用接口
a)定义变量，也可以用于进行强制类型转换
b)调用接口中定义的常量
c)被其他类实现

4.接口和抽象类
接口和抽象类很像，它们都具有如下特征：
a)接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
b)接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。
但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。
接口作为系统与外界交互的窗口，接口体现的是一种规范。制定了系统各模块应该遵循的标准，
因此一个系统中的接口不应该经常改变。一旦接口改变，对整个系统甚至其他系统的影响是辐射式的，导致系统中大部分类都需要改写。
抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统
实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有
更进一步的完善，这种完善可能有几种不同方式。


5.面向接口编程--简单工厂模式 --命令模式等


6.Java8新增的Lambda表达式



