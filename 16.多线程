1.线程和进程
几乎所有的操作系统都支持进程的概念，所有运行中的任务通常对应一个进程（process）。当一个程序进入内存运行时，即可变成一个进程。
进程是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单元。
进程有如下三个特征
a)独立性：进程是系统独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况，
一个用户进程不可以直接访问其他进程的地址空间。
b)动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己
的生周期和各种不同的状态，这些概念在程序中都是不具备的。
c)多个进程可以在单个处理器上并发进行，多个进程之间不会互相影响。

多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。线程 也被称作轻量级进程，线程是进程的执行单元。就像进程在操作系统的地位
一样，线程在程序中是独立的，并发的执行流。当进程被初始化后，主线程就被创建了。对于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以
在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。

2.多线程编程优点
a)进程之间不能共享内存，但线程之间共享内存非常容易。
b)系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小的多，因此使用多线程来实现多任务并发比多进程的效率高。
c)Java语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化Java多线程的编程。

3.线程的创建和启动
a)继承Thread类创建线程类【使用继承Thread类方法来创建线程类时，多个线程之间无法共享线程类的实例变量。】
Thread.currentThread():currentThread()是Thread类的静态方法，该方法总是返回当前正在执行的线程对象。
getName()：该方法是Thread类的实例方法，该方法返回调用该方法的线程名字。
b)实现Runnable接口创建线程类【采用Runnable接口的方式创建的多个线程可以共享线程类的实例变量这是因为在这种方式下，
程序所创建的Runnable对象只是线程的target，而多个线程可以共享一个target，所以多个线程可以共享同一个线程类的实例变量】
c)使用Callable和Future创建线程
Java5开始，Java提供Callable接口，该接口怎么看像是Runnable接口的增强版，Callable接口提供了一个call（）方法可以作为线程执行体，
但call()方法比run()方法功能更强大。
call()方法可以有返回值
call()方法可以声明抛出异常。
public class Thread1 implements Callable<Integer> {

	@Override
	public Integer call() throws Exception {

		int i = 0;
		for (; i < 100; i++) {
			System.out.println(Thread.currentThread().getName() + " 的循环变量i:"
					+ i);
		}
		return i;
	}

}
public static void main(String[] args) {
		Thread1 t1 = new Thread1();
		FutureTask<Integer> ft = new FutureTask<Integer>(t1);

		for (int i = 0; i < 100; i++) {
			System.out.println(Thread.currentThread().getName() + " 的循环变量i:"
					+ i);

			if (i == 20) {
				new Thread(ft, "有返回的线程").start();
			}
		}

		try {
			System.out.println("获取子线程的返回值: " + ft.get());
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


4.创建线程三种方式对比
采用实现Runnable、Callable接口的方式创建多线程的优缺点：
a)线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
b)在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，
从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现面向对象的思想。
劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。
c)采用继承Thread类方式创建多线程的优缺点：
劣势是，因为线程类继承了Thread类，所以不饿能够再继承其他父类。
优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用
this即可获得当前线程。
因此一般推荐采用Runnable接口、Callable接口方式创建多线程。


5.线程的生命周期
a)新建（new）
当程序使用new创建一个线程之后，该线程处于新建状态，仅仅由Java虚拟机分配内存
，并初始化其成员变量的值。此时线程对象没有表现出任何线程的动态特征，
程序也不会执行线程的执行体。
b)就绪（runnable）
线程对象调用start()方法之后，该线程处于就绪状态，Java虚拟机会为其
创建方法调用栈和程序计数器，处于这个状态的线程并没有开始运行，
只是表示该线程可以运行了，至于该线程和十三开始运行，取决于
JVM里线程调度器的调度。
【如果希望调用子线的start()方法后，子线程立即开始执行，程序可以使用
Thread.sleep(1)来让当前运行的线程（主线程）睡眠1毫秒，因为在这
1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样可以让子线程立即开始执行。】
c)运行（running）
d)阻塞（blocked）
当发生如下情况，线程将会进入阻塞状态
d1)调用sleep（）方法主动放弃所占用的处理器资源。
d2)调用了一个阻塞时IO方法，在该方法返回之前，该线程被阻塞。
d3)线程试图获得一个同步监视器，但该同步监视器正被其它线程所持有。
d4)线程在等待某个通知(notify)。
d5)程序调用了线程的suspend()方法将该线程挂起。但该方法容易导致死锁，所以尽量避免使用该方法。
当发生如下特定情况，可以解除上面的阻塞，让线程重新进入就绪状态。
d11)sleep()方法线程经过了指定时间。
d22)线程调用的阻塞IO方法已经返回。
d33)线程成功获得了试图取得的同步监视器。
d44)线程正在等待某个通知时，其他线程发出了一个通知。
d55)处于挂起状态的线程被调用了resume（）恢复方法。
e)死亡(dead)
线程会以如下三种方式结束，结束后就处于死亡状态。
e1)run()或call()方法执行完成，线程正常结束。
e2)线程抛出一个未捕获的Exception或Error。
e3)直接调用该线程stop()方法来结束该线程-该方法容易导致死锁，不推荐使用。
【当主线程结束时，其他线程不受任何影响，并不会随之结束，一旦线程启动起来后，它就拥有主线程相同的地位，它不会受主线程影响。】



6.控制线程
a)join线程
当在某个程序执行流中调用其他线程的join（）方法时，调用线程将被阻塞【例如主线程调用了某个子线程的join()方法，主线程被阻塞】，
直到被join()线程执行完为止。
b)后台线程
有一种线程，它是在后台运行的，它的任务是为其它线程提供服务，这种线程被称为后台线程（Daemon Thread）,又称为守护线程或精灵线程，
JVM的垃圾回收线程就是典型额后台线程。
后台线程有个特征，如果所有的前台线程都死亡，后台线程会自动死亡。
调用Thread对象的setDaemon(true)方法可以将指定的线程设置成后台线程，然后进行start()操作
主线程默认是前台线程，并不是所有的线程默认都是前台线程，有些线程默认就是后台线程，前台线程创建的子线程默认是前台线程，
后台线程创建的子线程默认是后台线程。
c)线程睡眠sleep
让当前正在执行的线程暂停一段时间，并进入阻塞状态。
d)线程让步yield
让当前正在执行的线程暂停，但不会阻塞该线程，它只是将该线程转入就绪状态。yield（）只是让当前线程暂停一下，让系统的线程调度器重新调度一次，
完全可能情况是，当某个线程调用了yield（）方法暂停之后，线程调度器又将其调度出来重新执行。
实际上，当某个线程调用yield()方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行机会。


